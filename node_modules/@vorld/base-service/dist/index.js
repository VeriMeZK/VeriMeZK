"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _service, _version, _buildVersion, _modelsPath, _app;
Object.defineProperty(exports, "__esModule", { value: true });
exports.metricsRegister = void 0;
const express_1 = __importDefault(require("express"));
const metrics_1 = __importDefault(require("./metrics"));
const prom_client_1 = __importDefault(require("prom-client"));
const cors_1 = __importDefault(require("cors"));
const schema_1 = require("./schema/schema");
const context_1 = require("./context");
const tracing_1 = require("./tracing");
var context_2 = require("./context");
Object.defineProperty(exports, "Context", { enumerable: true, get: function () { return context_2.Context; } });
exports.metricsRegister = prom_client_1.default.register;
prom_client_1.default.collectDefaultMetrics();
class BaseService {
    constructor(service, version, modelsPath) {
        _service.set(this, void 0);
        _version.set(this, void 0);
        _buildVersion.set(this, void 0);
        _modelsPath.set(this, void 0);
        _app.set(this, void 0);
        __classPrivateFieldSet(this, _service, service);
        __classPrivateFieldSet(this, _version, version);
        // TODO (avbasov) get rid of old GETID_SRV_VERSION variable
        __classPrivateFieldSet(this, _buildVersion, process.env.GETID_SRV_BUILD_VERSION || process.env.GETID_SRV_VERSION || version);
        __classPrivateFieldSet(this, _modelsPath, modelsPath);
        tracing_1.initTracer(__classPrivateFieldGet(this, _service), __classPrivateFieldGet(this, _version), __classPrivateFieldGet(this, _buildVersion));
    }
    startHttpTransport(port, jsonLimit = '50mb') {
        const app = express_1.default();
        __classPrivateFieldSet(this, _app, app);
        app.use(express_1.default.urlencoded({ extended: true }));
        app.use(express_1.default.json({ limit: jsonLimit }));
        app.options('*', cors_1.default());
        app.use(cors_1.default());
        this.setMetrics();
        this.setVersion();
        app.listen(port, () => {
            console.log(`server started at http://localhost:${port}`);
        });
    }
    startDefaultHttpTransport(jsonLimit) {
        this.startHttpTransport(8080, jsonLimit);
    }
    addHandler(Model, path, f) {
        const schema = schema_1.generateJsonSchema(__classPrivateFieldGet(this, _modelsPath), Model);
        schema.$ref = `#/definitions/${Model.name}`;
        const validate = schema_1.generateValidator(schema);
        __classPrivateFieldGet(this, _app).post(path, metrics_1.default, (req, res) => __awaiter(this, void 0, void 0, function* () {
            const [ctx, span] = tracing_1.withSpan2(new context_1.Context(), path, req.headers, { kind: tracing_1.SpanKind.SERVER });
            ctx.setValue('client', req.headers.client || '-');
            const [success, errors] = validate(req.body);
            try {
                if (!success) {
                    console.error(`ERROR: validation errors `, errors);
                    res.status(400).json({ errors });
                    span.setAttribute('error', true);
                    return;
                }
                try {
                    const resultData = yield f(ctx, req.body);
                    res.send({ data: resultData });
                }
                catch (e) {
                    console.error(`ERROR: internal error `, e);
                    res.status(500).send('internal error');
                    span.setAttribute('error', true);
                    span.recordException(e);
                }
            }
            finally {
                span.end();
            }
        }));
    }
    addExpandedHandler(type, path, func) {
        __classPrivateFieldGet(this, _app)[type](path, metrics_1.default, (req, res) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield func(req, res);
            }
            catch (e) {
                console.error(`ERROR: internal error `, e);
                res.status(500).send('internal error');
            }
        }));
    }
    addStatic(mountPath, root) {
        __classPrivateFieldGet(this, _app).use(mountPath, express_1.default.static(root));
    }
    setMetrics() {
        __classPrivateFieldGet(this, _app).get('/_/metrics', (req, res, next) => {
            res.set('Content-Type', prom_client_1.default.register.contentType);
            res.end(prom_client_1.default.register.metrics());
        });
    }
    setVersion() {
        __classPrivateFieldGet(this, _app).get('/_/version', (req, res, next) => {
            res.json({ service: __classPrivateFieldGet(this, _service), version: __classPrivateFieldGet(this, _version), buildVersion: __classPrivateFieldGet(this, _buildVersion) });
        });
        new prom_client_1.default.Gauge({
            name: 'srv_version_info',
            help: 'A metric with a constant \'1\' value labeled by service, its version and its build version.',
            labelNames: ['service', 'version', 'build_version'],
        }).set({ service: __classPrivateFieldGet(this, _service), version: __classPrivateFieldGet(this, _version), build_version: __classPrivateFieldGet(this, _buildVersion) }, 1);
    }
    setReadiness(func) {
        __classPrivateFieldGet(this, _app).get('/_/health/readiness', (req, res, next) => __awaiter(this, void 0, void 0, function* () {
            let status = 500;
            let message = 'Internal error';
            try {
                ({ status, message } = yield func());
            }
            catch (e) {
                console.error(`ERROR: internal error `, e);
            }
            finally {
                res.status(status).send({ message });
            }
        }));
    }
    setLiveness(func) {
        __classPrivateFieldGet(this, _app).get('/_/health/liveness', (req, res, next) => __awaiter(this, void 0, void 0, function* () {
            let status = 500;
            let message = 'Internal error';
            try {
                ({ status, message } = yield func());
            }
            catch (e) {
                console.error(`ERROR: internal error `, e);
            }
            finally {
                res.status(status).send({ message });
            }
        }));
    }
}
_service = new WeakMap(), _version = new WeakMap(), _buildVersion = new WeakMap(), _modelsPath = new WeakMap(), _app = new WeakMap();
// why? https://stackoverflow.com/a/38693275/4837022
const Service = BaseService;
exports.default = Service;
//# sourceMappingURL=index.js.map