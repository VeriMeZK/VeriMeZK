import express from 'express';
import prometheusMiddleware from './metrics';
import Prometheus from "prom-client";
import cors from 'cors';

import { ModelConstructor, generateJsonSchema, generateValidator } from "./schema/schema";
import { Context } from "./context";
import { initTracer, withSpan2, SpanKind } from './tracing'

export { Context } from './context'
export const metricsRegister = Prometheus.register
Prometheus.collectDefaultMetrics()


class BaseService {
    #service: string;
    #version: string;
    #buildVersion: string;
    #modelsPath: string;
    #app: express.Express;
    constructor(service: string, version: string, modelsPath: string) {
        this.#service = service;
        this.#version = version;
        // TODO (avbasov) get rid of old GETID_SRV_VERSION variable
        this.#buildVersion = process.env.GETID_SRV_BUILD_VERSION || process.env.GETID_SRV_VERSION || version;
        this.#modelsPath = modelsPath;
        initTracer(this.#service, this.#version, this.#buildVersion)

    }

    startHttpTransport(port: number, jsonLimit = '50mb'): void {

        const app = express();
        this.#app = app
        app.use(express.urlencoded({ extended: true }))
        app.use(express.json({ limit: jsonLimit }));
        app.options('*', cors());
        app.use(cors());
        this.setMetrics();
        this.setVersion();
        app.listen(port, () => {
            console.log(`server started at http://localhost:${port}`);
        });

    }

    startDefaultHttpTransport(jsonLimit?: string): void {
        this.startHttpTransport(8080, jsonLimit)
    }

    addHandler<T extends object>(Model: ModelConstructor<T>, path: string, f: (ctx: Context, data: T) => void): void {
        const schema = generateJsonSchema(this.#modelsPath, Model);
        schema.$ref = `#/definitions/${Model.name}`;
        const validate = generateValidator(schema);
        this.#app.post(path, prometheusMiddleware, async (req: any, res: any) => {
            const [ctx, span] = withSpan2(new Context(), path, req.headers, { kind: SpanKind.SERVER })
            ctx.setValue('client', req.headers.client || '-')
            const [success, errors] = validate(req.body);
            try {
                if (!success) {
                    console.error(`ERROR: validation errors `, errors);
                    res.status(400).json({ errors });
                    span.setAttribute('error', true);
                    return;
                }
                try {
                    const resultData = await f(ctx, req.body);
                    res.send({ data: resultData });
                } catch (e) {
                    console.error(`ERROR: internal error `, e);
                    res.status(500).send('internal error');
                    span.setAttribute('error', true);
                    span.recordException(e);
                }
            } finally {
                span.end()
            }
        });
    }

    addExpandedHandler<T extends object>(type: keyof express.Application, path: string, func: (req: express.Request, res: express.Response) => void): void {
        this.#app[type](path, prometheusMiddleware, async (req: any, res: any) => {
            try {
                await func(req, res);
            } catch (e) {
                console.error(`ERROR: internal error `, e);
                res.status(500).send('internal error');
            }
        });
    }

    addStatic(mountPath: string, root: string): void {
        this.#app.use(mountPath, express.static(root));
    }

    private setMetrics(): void {
        this.#app.get('/_/metrics', (req: express.Request, res: express.Response, next: () => void) => {
            res.set('Content-Type', Prometheus.register.contentType)
            res.end(Prometheus.register.metrics())
        })
    }

    private setVersion(): void {
        this.#app.get('/_/version', (req: express.Request, res: express.Response, next: () => void) => {
            res.json({ service: this.#service, version: this.#version, buildVersion: this.#buildVersion })
        });
        new Prometheus.Gauge({
            name: 'srv_version_info',
            help: 'A metric with a constant \'1\' value labeled by service, its version and its build version.',
            labelNames: ['service', 'version', 'build_version'],
        }).set({ service: this.#service, version: this.#version, build_version: this.#buildVersion }, 1);
    }

    setReadiness(func: () => Promise<{ status: number; message: string; }>) {
        this.#app.get('/_/health/readiness', async (req: express.Request, res: express.Response, next: () => void) => {
            let status = 500;
            let message = 'Internal error';
            try {
                ({ status, message } = await func());
            } catch (e) {
                console.error(`ERROR: internal error `, e);
            } finally {
                res.status(status).send({ message });
            }
        })
    }

    setLiveness(func: () => Promise<{ status: number; message: string; }>) {
        this.#app.get('/_/health/liveness', async (req: express.Request, res: express.Response, next: () => void) => {
            let status = 500;
            let message = 'Internal error';
            try {
                ({ status, message } = await func());
            } catch (e) {
                console.error(`ERROR: internal error `, e);
            } finally {
                res.status(status).send({ message });
            }
        })
    }
}



// why? https://stackoverflow.com/a/38693275/4837022
const Service = BaseService;
export default Service;
