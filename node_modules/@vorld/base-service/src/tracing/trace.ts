
import { Context } from "../context";

import api, { Span, Context as SpanContext, SpanOptions, context } from '@opentelemetry/api';
export { SpanKind } from '@opentelemetry/api';

import { tracer } from './tracer'
import { hrTime } from '@opentelemetry/core';
function getCurrentSpanCtx(ctx: Context): SpanContext {
  return ctx.spanCtx
}
function injectSpanCtx(ctx: Context, sc: SpanContext): void {
  ctx.spanCtx = sc;
}


/**
 *
 * @param {Context} ctx - context
 * @param {string} name - span name
 * @param {api.SpanOptions} options - span config
 */
const withSpan = (ctx: Context, name: string = 'uncaught_span', options?: SpanOptions): [Context, Span] => {
  const traceCtx = getCurrentSpanCtx(ctx) || api.context.active();
  const span = tracer.startSpan(name, options, traceCtx);
  const newCtx = ctx.clone();
  injectSpanCtx(newCtx, api.trace.setSpan(traceCtx, span))
  return [newCtx, span];
};


/**
 * @param {Context} ctx - context
 * @param {string} name - span name
 * @param {api.SpanOptions} options - span config
 */
export const withSpan2 = (ctx: Context, name: string, carrier: {}, options?: SpanOptions): [Context, Span] => {

  const newCtx = ctx.clone();
  const span = context.with(
    api.propagation.extract(context.active(), carrier), () => {
      options.startTime = hrTime()
      const sp = tracer.startSpan(name, options);
      sp.spanContext().isRemote = true
      newCtx.spanCtx = sp.spanContext()
      return sp
    }
  )
  return [newCtx, span];
};

interface SpanProps {
  name?: string
  attributeFromResult?: {
    name: string
    extract: (x: any) => any
  }
}
class SpanBuilder {
  name: string
  attributeFromResult: {
    name?: string
    extract?: (x: any) => any,
  }
  constructor(props?: SpanProps) {
    this.name = props?.name;
    this.attributeFromResult = props?.attributeFromResult;
  }

  decorate(f: (...args: any[]) => void) {
    if (typeof f !== 'function') {
      throw new Error('decorated function is not provided');
    }
    const self = this;
    const name = this.name || f.name;
    if (f.constructor.name === 'Function') {
      return function _traceWrapper(origCtx: Context, ...args: any[]) {
        if (!origCtx) return f.call(this, origCtx, ...args);

        const [ctx, span] = withSpan(origCtx, name);

        try {
          const result = f.call(this, ctx, ...args);
          self._addAttributes(span, result);
          return result;
        } catch (e) {
          span.setAttribute('error', true);
          span.recordException(e);
          throw e;
        } finally {
          span.end();
        }
      };
    }

    if (f.constructor.name === 'AsyncFunction') {
      return async function _traceWrapper(origCtx: Context, ...args: any[]) {
        if (!origCtx) return await f.call(this, origCtx, ...args);

        const [ctx, span] = withSpan(origCtx, name);

        try {
          const result = await f.call(this, ctx, ...args);
          self._addAttributes(span, result);
          return result;
        } catch (e) {
          span.setAttribute('error', true);
          span.recordException(e);
          throw e;
        } finally {
          span.end();
        }
      };
    }

    throw new Error('decorated function is not provided');
  }

  _addAttributes(span: Span, result: any) {
    if (this.attributeFromResult) {
      try {
        const value = this.attributeFromResult.extract(result);
        span.setAttribute(this.attributeFromResult.name, value);
      } catch (e) {
        console.warn(
          `Could not extract tracing attribute "${this.attributeFromResult.name}" from result: ${e}`,
        );
      }
    }
  }
}

export const traceDecorate = (f: (...args: any[]) => void) => new SpanBuilder().decorate(f)
export const traceWithParams = (spanProps: SpanProps) => new SpanBuilder(spanProps)
export const traceWithAttribute = (name: string) => ({
  // add 'getid.' to custom attributes
  fromResult: (extract = (x: any) => x) => new SpanBuilder({
    attributeFromResult: {
      name: `getid.${name}`,
      extract,
    }
  }),
})
