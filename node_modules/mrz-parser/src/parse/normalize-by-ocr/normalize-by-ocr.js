/* eslint-disable no-param-reassign */
const moment = require('moment');
const isoCountries = require('i18n-iso-countries');
isoCountries.registerLocale(require('i18n-iso-countries/langs/en.json'));
const parseMrzWithInfo = require('../parse');
const categories = require('../../ocr-template/ocr-categories');
const normalizeExpirationDate = require('../../corner-case-handlers/normalizers');

const sexConvert = (sex) => {
  const normalizedValue = sex.toLowerCase();
  const maleSexSet = new Set(['m', 'male', 'м', 'masculino', 'laki-laki']);
  const femaleSexSet = new Set(['f', 'female', 'woman', 'ж', 'laki-laki', 'perempuan']);

  if (maleSexSet.has(normalizedValue)) {
    return 'male';
  }
  if (femaleSexSet.has(normalizedValue)) {
    return 'female';
  }
  if (normalizedValue === 'nonspecified') {
    return '';
  }
  return '-';
};

const templates = {
  documentNumber: categories.documentNumber,
  firstName: categories.firstName,
  lastName: categories.lastName,
  personalNumber: categories.personalNumber,
  nationality: categories.nationalityCode,
  issuingState: categories.country,
  sex: categories.gender,
  expirationDate: categories.dateOfExpiry,
  birthDate: categories.dateOfBirth,
  issueDate: categories.dateOfIssue,
  optional: categories.optionalData,
  optional1: categories.optionalData,
  optional2: categories.optionalData2,
};

function formatDate(category, value) {
  if (value?.length === 8) {
    const date = moment(value, 'YYYYMMDD').format('YYYY-MM-DD');
    return date === 'Invalid date' ? null : date;
  }

  if (value?.length !== 6) {
    console.log(`Bad date value: '${value}'`);
    return null;
  }

  const year = parseInt(value.slice(0, 2), 10);
  const currentYear = new Date().getFullYear() - 2000;
  let fullYear = year + 2000;

  if (category === 'Date of expiry') {
    fullYear = year + 2000;
  } else if (currentYear < year) {
    fullYear = year + 1900;
  }

  const date = moment(fullYear + value?.slice(2), 'YYYYMMDD').format('YYYY-MM-DD');
  return date === 'Invalid date' ? null : date;
}

const normalizeCountry = (value) => {
  if (value === 'D') {
    return 'DEU';
  }
  if (value === 'ROM') {
    return 'ROM';
  }
  if (value.length === 2 && isoCountries.getName(value, 'en')) {
    return isoCountries.toAlpha3(value, 'en').toUpperCase();
  }
  if (isoCountries.getName(value, 'en')) {
    return value.toUpperCase();
  }
  console.log(`Bad country value: '${value}'`);
  return null;
};

function getContent(category, contentType, value) {
  switch (contentType) {
    case 'sex':
      return sexConvert(value);
    case 'date':
      return formatDate(category, value);
    case 'country':
      return normalizeCountry(value);
    default:
      return value;
  }
}

const { mrzFull, documentType } = categories;
const residencePermits = new Set(['AR', 'CP', 'CR', 'RP', 'TP', 'TS']);

const getFullDocName = (docCode, docNumber, issueCountry) => {
  if (!docCode) {
    return 'unknown';
  }

  if (residencePermits.has(docCode)) {
    return 'residence-permit';
  }

  if (docCode === 'I' && (issueCountry === 'DNK')) {
    return 'residence-permit';
  }

  if (issueCountry === 'MEX') {
    if (docCode === 'I') return 'residence-permit';
    if (docCode === 'ID') return 'voter-card';
    if (docCode === 'CG') return 'id-card';
  }

  const first = docCode.charAt(0);
  if (issueCountry === 'HRV') {
    if (first === 'I') {
      return 'id-card';
    }
    if (first === 'A') {
      return 'residence-permit';
    }
  }

  if (issueCountry === 'CHL' && first === 'I') {
    return 'id-card';
  }

  if (docCode === 'I' || docCode === 'ID') {
    if (issueCountry === 'BEL') {
      if (docNumber.length === 12) {
        return 'id-card';
      }
      return 'residence-permit';
    }
    return 'id-card';
  }

  if (docCode === 'IA' && issueCountry === 'AZE') {
    return 'id-card';
  }

  if (docCode === 'BI' && issueCountry === 'MOZ') {
    return 'id-card';
  }

  if (docCode === 'IN' && issueCountry === 'LVA') {
    return 'id-card';
  }

  switch (first) {
    case 'P':
      return 'passport';
    case 'A':
    case 'C':
      return 'id-card';
    case 'B':
    case 'D':
    case 'F':
      return 'driving-licence';
    case 'T':
    case 'I':
    case 'R':
      return 'residence-permit';
    default:
      return 'unknown';
  }
};

const calculateAge = (birthDate) => {
  const formatedBirthDate = formatDate('Date of birth', birthDate);
  return moment().diff(formatedBirthDate, 'year');
};

const getTemplate = (issuingState, field) => {
  if (issuingState === 'KEN' && field === 'personalNumber') {
    return templates.optional1;
  }
  return templates[field];
};

const specialDateCases = (category, countryCode, docCode, details, value = '') => {
  let extractedFormat = 'YYYY-MM-DD';
  const cd = docCode?.toUpperCase();

  if (category === 'Date of expiry') {
    const birthDate = (details.find((x) => x.field === 'birthDate') || { value: null }).value;
    const age = calculateAge(birthDate);
    const normalizedValue = normalizeExpirationDate(countryCode, cd, value, age);

    return [normalizedValue, extractedFormat];
  }

  if (category === 'Date of issue' && countryCode === 'FRA' && value?.length === 4 && (cd === 'I' || cd === 'ID')) {
    extractedFormat = 'YYYY-MM';
    return [`${value}01`, 'YYYY-MM'];
  }

  return [value, extractedFormat];
};

const dateToTimestampNumber = (date) => Number(moment(date).format('X'));

const handleDocumentNumberSpecialCases = (countryCode, docCode, value, dateOfIssue) => {
  if (countryCode === 'IRL' && docCode === 'D') {
    const dateOfIssueForSpecialCase = '2013-01-19';
    const dateOfIssueTimestamp = dateToTimestampNumber(dateOfIssue);
    const dateOfIssueForSpecialCaseTimestamp = dateToTimestampNumber(dateOfIssueForSpecialCase);
    return dateOfIssueTimestamp > dateOfIssueForSpecialCaseTimestamp ? value.slice(0, -1) : value;
  }
  return value;
};

const toField = (details, val, countryCode, docCode, dateOfIssue = null) => {
  let { value } = val;
  let extractedFormat = null;
  const { field, error, valid } = val;

  if (field === 'documentCode' && value === null) {
    return null;
  }
  try {
    const template = getTemplate(countryCode, field);
    if (!template) {
      return null;
    }

    const { contentType, category, mrzChecksum } = template;
    if (contentType === 'date') {
      [value, extractedFormat] = specialDateCases(category, countryCode, docCode, details, value);
    }
    if (field === 'documentNumber') {
      value = handleDocumentNumberSpecialCases(countryCode, docCode, value, dateOfIssue);
    }
    const content = getContent(category, contentType, value || '');

    if (!content) {
      return null;
    }
    let isValid = valid;
    if (isValid && mrzChecksum) {
      isValid = (details.find((x) => x.field === mrzChecksum) || { valid }).valid;
    }
    const convertedField = {
      error,
      category,
      content,
      contentType,
      valid: isValid,
    };
    if (extractedFormat) {
      convertedField.extractedFormat = extractedFormat;
    }
    return convertedField;
  } catch (e) {
    console.log(e);
    return null;
  }
};

const mrzCheckDigitMapper = {
  documentNumberCheckDigit: 'Document number',
  birthDateCheckDigit: 'Date of birth',
  expirationDateCheckDigit: 'Date of expiry',
};

const mrzFieldsToReplace = [
  'documentNumber',
  'expirationDate',
  'birthDate',
  'issueDate',
  'personalNumber',
];

function setSubstringAt(str, start, end, substr) {
  if (str.length < end) return str;
  return str.substring(0, start) + substr + str.substring(end);
}

function replaceMrzData(mrzArr, mrzData, ocrContent) {
  if (!mrzData) return mrzArr;
  const {
    line, start, end, raw = '',
  } = mrzData;
  mrzArr[line] = setSubstringAt(
    mrzArr[line],
    start,
    end,
    ocrContent || raw.replace(/[0-9<]+O+/g, (f) => f.replace(/O/g, '0'))
      .replace(/O+[0-9<]|$/g, (f) => f.replace(/O/g, '0')),
  );
  return mrzArr;
}

const invalidFields = (arr) => arr.filter((item) => !item.valid);

function checkDigitsZero(mrzArr, details) {
  const invalidChecks = invalidFields(details).filter((item) => item.ranges[0].raw.includes('O')).filter((x) => mrzFieldsToReplace.includes(x.field));
  if (!invalidChecks.length) return [false, mrzArr];
  for (const check of invalidChecks) {
    mrzArr = replaceMrzData(mrzArr, check.ranges[0]);
  }
  return [true, mrzArr];
}

function checkFieldsZeroByOcr(mrzArr, details, ocr) {
  const invalidChecks = invalidFields(details).filter((item) => !item.field.includes('Date'));
  if (!invalidChecks.length) return [false, mrzArr];
  for (const check of invalidChecks) {
    const fieldName = mrzCheckDigitMapper[check.field];
    if (fieldName) {
      const { raw } = check.ranges.length ? check.ranges[1] : {};
      const ocrField = ocr.find?.((item) => item.category === fieldName
        && item.content !== raw
        && item.content?.replace?.(/O/g, 0) === raw?.replace(/O/g, 0));

      if (ocrField) mrzArr = replaceMrzData(mrzArr, check.ranges[1], ocrField.content);
    }
  }
  return [true, mrzArr];
}

function checkDigitIsO(mrzArr, details) {
  const invalidChecks = invalidFields(details).filter((x) => x.field.includes('CheckDigit'));
  if (!invalidChecks.length) return [false, mrzArr];
  let changed = false;
  for (const check of invalidChecks) {
    const {
      raw, start, end, line,
    } = check?.ranges?.[0] || {};
    if (raw === 'O') {
      mrzArr[line] = setSubstringAt(
        mrzArr[line],
        start,
        end,
        0,
      );
      changed = true;
    }
  }
  return [changed, mrzArr];
}

function checkFieldsZero(mrzArr, details) {
  const invalidChecks = invalidFields(details);
  if (!invalidChecks.length) return [false, mrzArr];
  for (const check of invalidChecks) {
    mrzArr = replaceMrzData(mrzArr, check.ranges[1]);
  }
  return [true, mrzArr];
}

async function normalizeAndParseMrz(fullMrz, ocr) {
  let { details, valid } = parseMrzWithInfo(fullMrz);
  if (valid) return [details, fullMrz];

  let mrzArray = fullMrz.split('\n');
  let changed = false;

  const zeroCheckFlow = [checkDigitIsO, checkDigitsZero, checkFieldsZeroByOcr, checkFieldsZero];

  for (const check of zeroCheckFlow) {
    [changed, mrzArray] = check(mrzArray, details, ocr);
    if (changed) {
      const checkedMrz = mrzArray.join('\n');
      ({ details, valid } = parseMrzWithInfo(checkedMrz));
      if (valid) return [details, checkedMrz];
    }
  }
  return [details, fullMrz];
}

async function normalizeMrz(fullMrz, ocr = []) {
  const [details, checkedMrz] = await normalizeAndParseMrz(fullMrz, ocr);

  const issuingState = (details.find((x) => x.field === 'issuingState'))?.value;
  const ocrIssuingState = (ocr.find((x) => x.category === 'Issue country'))?.content;
  const dateOfIssue = (ocr.find((x) => x.category === 'Date of issue'))?.content;

  const countryCode = issuingState || ocrIssuingState;

  const docCode = ((details.find((x) => x.field === 'documentCode'))?.value || '').toUpperCase();

  const fields = details.map((f) => toField(details, f, countryCode, docCode, dateOfIssue))
    .filter((x) => x);

  const docNumber = (fields.find((x) => x.category === 'Document number'))?.content;

  const fullDocumentName = getFullDocName(docCode, docNumber, countryCode);

  return [
    ...fields,
    {
      category: documentType.category,
      content: fullDocumentName,
      contentType: documentType.contentType,
      valid: fullDocumentName !== null,
    },
    {
      category: mrzFull.category,
      content: checkedMrz,
      contentType: mrzFull.contentType,
      valid: details.every((x) => x.valid),
    },
  ];
}

module.exports = {
  normalizeMrz,
};
